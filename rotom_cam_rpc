# ============================================================
# OBS WINDOW SCREENSHOT TOOL (Windows + Tkinter)
# ------------------------------------------------------------
# - 6 tabs (profiles), each with independent settings + config file
# - Press Start to begin auto-check at configured frequency
# - Press Stop to pause checking
# - If match: increment a number in a selected .txt file
# - Cooldown after a match before checking again
# - Load/save settings from per-profile config files
# - Shows current count and running status in UI
# - No screenshot file is saved (in-memory compare only)
# - Manual +/- buttons to increment/decrement by 1
# - Configurable sliders in a Configure window
# - Editable profile names (tab titles)
# - Test image button with live detection + confidence
# - Barebones RPC broadcast integration per profile
# ============================================================

# =========================
# IMPORTS
# =========================
import os
import sys
import time
import ctypes
import threading
import tkinter as tk
from ctypes import wintypes
from tkinter import messagebox, filedialog, ttk, simpledialog
from PIL import Image, ImageTk

try:
    from pypresence import Presence
except Exception:
    Presence = None

try:
    import keyboard
except Exception:
    keyboard = None

import cv2
import numpy as np


# =========================
# THEME
# =========================
DARK_BG = "#1e1e1e"
DARK_FG = "#e6e6e6"
DARK_ACCENT = "#2d2d2d"
DARK_BUTTON = "#3a3a3a"
DARK_BORDER = "#444444"
BUTTON_PADX = 12
BUTTON_PADY = 0
BUTTON_HEIGHT = 1
COUNTER_BUTTON_HEIGHT = 1
FONT_NAME = "Pokémon DP Pro Regular"
FONT_FILENAME = "pokemon-dp-pro.ttf"
FR_PRIVATE = 0x10
BASE_FONT_SIZE = 18
LARGE_FONT_SIZE = 24
SMALL_BUTTON_FONT_SIZE = 16
TAB_FONT_SIZE = BASE_FONT_SIZE + 2
TABLE_WIDTH = 650
TABLE_HEIGHT = 600
RPC_ICON_SIZE = 24
PROFILE_NAME_MAX_LENGTH = 12
MIN_INCREMENT = 1
MAX_INCREMENT = 99


def resource_path(relative_path):
    base_path = getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, relative_path)


def register_font(font_path):
    if not os.path.isfile(font_path):
        return False
    return ctypes.windll.gdi32.AddFontResourceExW(font_path, FR_PRIVATE, 0) > 0


def apply_dark_theme(root):
    root.configure(bg=DARK_BG)
    root.option_add("*Background", DARK_BG)
    root.option_add("*Foreground", DARK_FG)
    root.option_add("*Button.Background", DARK_BUTTON)
    root.option_add("*Button.Foreground", DARK_FG)
    root.option_add("*Entry.Background", DARK_ACCENT)
    root.option_add("*Entry.Foreground", DARK_FG)
    root.option_add("*Entry.InsertBackground", DARK_FG)
    root.option_add("*Entry.Justify", "left")
    root.option_add("*Checkbutton.Background", DARK_BG)
    root.option_add("*Checkbutton.Foreground", DARK_FG)
    root.option_add("*Label.Background", DARK_BG)
    root.option_add("*Label.Foreground", DARK_FG)
    root.option_add("*Scale.Background", DARK_BG)
    root.option_add("*Scale.Foreground", DARK_FG)
    root.option_add("*Listbox.Background", DARK_ACCENT)
    root.option_add("*Listbox.Foreground", DARK_FG)
    root.option_add("*Font", (FONT_NAME, BASE_FONT_SIZE))

    style = ttk.Style(root)
    style.theme_use("clam")
    style.configure("TFrame", background=DARK_BG)
    style.configure("TLabel", background=DARK_BG, foreground=DARK_FG)
    style.configure("TNotebook", background=DARK_BG, bordercolor=DARK_BG, borderwidth=0)
    style.configure(
        "TNotebook.Tab",
        background=DARK_ACCENT,
        foreground=DARK_FG,
        font=(FONT_NAME, TAB_FONT_SIZE),
        borderwidth=0,
        padding=[8, 4]
    )
    style.map(
        "TNotebook.Tab",
        background=[("selected", DARK_BUTTON)],
        foreground=[("selected", DARK_FG)]
    )
    style.configure("TButton", background=DARK_BUTTON, foreground=DARK_FG)
    style.map("TButton", background=[("active", "#505050")])
    style.configure(
        "Treeview",
        background=DARK_ACCENT,
        fieldbackground=DARK_ACCENT,
        foreground=DARK_FG
    )
    style.configure("Treeview.Heading", background=DARK_BUTTON, foreground=DARK_FG)
    style.configure(
        "TScrollbar",
        background=DARK_BUTTON,
        troughcolor=DARK_BG,
        arrowcolor=DARK_FG
    )


# =========================
# PATHS
# =========================
SCRIPT_FOLDER = os.path.dirname(os.path.abspath(__file__))
RPC_CONFIG_FOLDER = os.path.join(SCRIPT_FOLDER, "rpc_config")
REFERENCES_FOLDER = os.path.join(SCRIPT_FOLDER, "references")
HOTKEYS_CONFIG_PATH = os.path.join(SCRIPT_FOLDER, "hotkeys_config.txt")
ICON_PATH = os.path.join(SCRIPT_FOLDER, "assets", "rotom", "main", "main_icon.ico")
FONT_PATH = resource_path(os.path.join("fonts", FONT_FILENAME))
os.makedirs(RPC_CONFIG_FOLDER, exist_ok=True)
os.makedirs(REFERENCES_FOLDER, exist_ok=True)


# =========================
# HOTKEY DEFAULTS
# =========================
DEFAULT_HOTKEYS = {
    "start_stop": "F1",
    "capture": "F2",
    "count_plus": "",
    "count_minus": "",
}


# =========================
# GLOBALS
# =========================
ACTIVE_BROADCAST_PROFILE = None
hotkey_manager = None


# =========================
# RPC COUNTER OPTIONS
# =========================
CONFIG_KEY_RPC_SUFFIX = "rpc_counter_suffix:"
RPC_COUNTER_OPTIONS = [
    ("Soft Reset", "SRs"),
    ("Random Encounter", "REs"),
    ("Run Away", "RAs"),
    ("Breeding", "Hatched"),
    ("Default / Other", "Encounters"),
]


# =========================
# WINDOW ICON + TITLE
# =========================
def apply_window_style(window, title="RotomCamRPC"):
    window.title(title)
    try:
        if os.path.isfile(ICON_PATH):
            window.iconbitmap(ICON_PATH)
    except Exception:
        pass


def open_hotkeys_window():
    if hotkey_manager is None:
        return

    win = tk.Toplevel(root)
    apply_window_style(win)
    win.resizable(False, False)
    win.transient(root)
    win.grab_set()

    hotkey_manager.suspend()

    container = tk.Frame(win, bg=DARK_BG)
    container.pack(padx=12, pady=12)

    entries = {}

    def add_row(row, label_text, key):
        tk.Label(container, text=label_text).grid(row=row, column=0, sticky="w", pady=4)
        entry = tk.Entry(container, width=20)
        entry.grid(row=row, column=1, padx=8, pady=4, sticky="w")
        entry.insert(0, hotkey_manager.hotkeys.get(key, ""))
        entries[key] = entry

    profile = get_active_profile()
    profile_name = profile.profile_name_var.get().strip() if profile else ""
    profile_label = profile_name or (profile.default_tab_name if profile else "Profile")

    tk.Label(container, text="Global:", font=(FONT_NAME, BASE_FONT_SIZE, "bold")).grid(
        row=0, column=0, columnspan=2, sticky="w", pady=(0, 4)
    )
    add_row(1, "Start / Stop:", "start_stop")
    add_row(2, "Capture:", "capture")

    tk.Label(container, text=f"{profile_label}:", font=(FONT_NAME, BASE_FONT_SIZE, "bold")).grid(
        row=3, column=0, columnspan=2, sticky="w", pady=(8, 4)
    )
    add_row(4, "+ Count:", "count_plus")
    add_row(5, "- Count:", "count_minus")

    global_var = tk.BooleanVar(value=hotkey_manager.global_enabled)
    global_check = tk.Checkbutton(
        container,
        text="Enable hotkeys while minimized",
        variable=global_var
    )
    global_check.grid(row=6, column=0, columnspan=2, sticky="w", pady=(8, 4))

    if keyboard is None:
        global_check.config(state="disabled")
        tk.Label(
            container,
            text="Install the 'keyboard' package to enable global hotkeys.",
            fg="#d46a6a"
        ).grid(row=7, column=0, columnspan=2, sticky="w")

    def apply_changes():
        new_hotkeys = {}
        for key, entry in entries.items():
            new_hotkeys[key] = normalize_hotkey_display(entry.get().strip())

        enabled = hotkey_manager.set_global_enabled(global_var.get())
        hotkey_manager.set_hotkeys(new_hotkeys)
        save_hotkeys_config(hotkey_manager.hotkeys, enabled)
        hotkey_manager.resume()
        win.destroy()

    def on_close():
        hotkey_manager.resume()
        win.destroy()

    button_row = tk.Frame(win, bg=DARK_BG)
    button_row.pack(padx=12, pady=(0, 12), fill="x")

    tk.Button(
        button_row,
        text="Save",
        command=apply_changes,
        padx=BUTTON_PADX,
        pady=BUTTON_PADY,
        height=BUTTON_HEIGHT
    ).pack(side="left", padx=(0, 4))
    tk.Button(
        button_row,
        text="Cancel",
        command=on_close,
        padx=BUTTON_PADX,
        pady=BUTTON_PADY,
        height=BUTTON_HEIGHT
    ).pack(side="left", padx=(4, 0))

    win.protocol("WM_DELETE_WINDOW", on_close)

    center_window(win, root)


# =========================
# WINDOW HELPERS
# =========================
def center_window(child, parent):
    child.update_idletasks()
    child_w = child.winfo_width()
    child_h = child.winfo_height()

    parent_x = parent.winfo_rootx()
    parent_y = parent.winfo_rooty()
    parent_w = parent.winfo_width()
    parent_h = parent.winfo_height()

    x = parent_x + (parent_w // 2) - (child_w // 2)
    y = parent_y + (parent_h // 2) - (child_h // 2)

    child.geometry(f"+{x}+{y}")


# =========================
# WINDOWS API HELPERS
# =========================
user32 = ctypes.WinDLL("user32", use_last_error=True)
gdi32 = ctypes.WinDLL("gdi32", use_last_error=True)

EnumWindows = user32.EnumWindows
EnumWindowsProc = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_void_p, ctypes.c_void_p)
GetWindowText = user32.GetWindowTextW
GetWindowTextLength = user32.GetWindowTextLengthW
IsWindowVisible = user32.IsWindowVisible
IsIconic = user32.IsIconic
GetClientRect = user32.GetClientRect
ClientToScreen = user32.ClientToScreen
GetWindowRect = user32.GetWindowRect
GetWindowDC = user32.GetWindowDC
ReleaseDC = user32.ReleaseDC
PrintWindow = user32.PrintWindow

CreateCompatibleDC = gdi32.CreateCompatibleDC
CreateCompatibleBitmap = gdi32.CreateCompatibleBitmap
SelectObject = gdi32.SelectObject
DeleteObject = gdi32.DeleteObject
DeleteDC = gdi32.DeleteDC
GetDIBits = gdi32.GetDIBits
BitBlt = gdi32.BitBlt

BI_RGB = 0
DIB_RGB_COLORS = 0
SRCCOPY = 0x00CC0020


class BITMAPINFOHEADER(ctypes.Structure):
    _fields_ = [
        ("biSize", ctypes.c_ulong),
        ("biWidth", ctypes.c_long),
        ("biHeight", ctypes.c_long),
        ("biPlanes", ctypes.c_ushort),
        ("biBitCount", ctypes.c_ushort),
        ("biCompression", ctypes.c_ulong),
        ("biSizeImage", ctypes.c_ulong),
        ("biXPelsPerMeter", ctypes.c_long),
        ("biYPelsPerMeter", ctypes.c_long),
        ("biClrUsed", ctypes.c_ulong),
        ("biClrImportant", ctypes.c_ulong),
    ]


class BITMAPINFO(ctypes.Structure):
    _fields_ = [("bmiHeader", BITMAPINFOHEADER), ("bmiColors", ctypes.c_ulong * 3)]


# =========================
# CONFIG KEYS
# =========================
CONFIG_KEY_PROFILE_NAME = "profile_name:"
CONFIG_KEY_TITLE = "title_window:"
CONFIG_KEY_COOLDOWN = "cooldown_seconds:"
CONFIG_KEY_FREQUENCY = "frequency_seconds:"
CONFIG_KEY_THRESHOLD = "match_threshold:"
CONFIG_KEY_IMAGE = "image_path:"
CONFIG_KEY_TEXT = "text_path:"
CONFIG_KEY_INCREMENT = "increment_amount:"
CONFIG_KEY_RPC_GAME = "rpc_game:"
CONFIG_KEY_RPC_TARGET = "rpc_target:"
CONFIG_KEY_RPC_ODDS = "rpc_odds:"
CONFIG_KEY_RPC_ENABLED = "rpc_enabled:"


# =========================
# IMAGE / WINDOW HELPERS
# =========================
def find_window_by_title_exact(target_title):
    found_hwnd = None

    def enum_proc(hwnd, _lparam):
        nonlocal found_hwnd
        if not IsWindowVisible(hwnd):
            return True

        length = GetWindowTextLength(hwnd)
        if length == 0:
            return True

        buffer = ctypes.create_unicode_buffer(length + 1)
        GetWindowText(hwnd, buffer, length + 1)
        title = buffer.value

        if title == target_title:
            found_hwnd = hwnd
            return False
        return True

    EnumWindows(EnumWindowsProc(enum_proc), 0)
    return found_hwnd


def list_window_titles():
    titles = []

    def enum_proc(hwnd, _lparam):
        if not IsWindowVisible(hwnd):
            return True

        length = GetWindowTextLength(hwnd)
        if length == 0:
            return True

        buffer = ctypes.create_unicode_buffer(length + 1)
        GetWindowText(hwnd, buffer, length + 1)
        title = buffer.value.strip()

        if title:
            titles.append(title)

        return True

    EnumWindows(EnumWindowsProc(enum_proc), 0)
    titles.sort(key=str.lower)
    return titles


def is_window_minimized(hwnd):
    return bool(IsIconic(hwnd))


def grab_window_image(hwnd):
    window_rect = wintypes.RECT()
    if not GetWindowRect(hwnd, ctypes.byref(window_rect)):
        raise RuntimeError("Failed to get window rect.")

    window_width = window_rect.right - window_rect.left
    window_height = window_rect.bottom - window_rect.top

    if window_width <= 0 or window_height <= 0:
        raise RuntimeError("Invalid window size.")

    hwnd_dc = GetWindowDC(hwnd)
    mem_dc = CreateCompatibleDC(hwnd_dc)
    bitmap = CreateCompatibleBitmap(hwnd_dc, window_width, window_height)
    SelectObject(mem_dc, bitmap)

    result = PrintWindow(hwnd, mem_dc, 0x00000002)
    if not result:
        result = PrintWindow(hwnd, mem_dc, 0x00000000)

    if not result:
        if not BitBlt(mem_dc, 0, 0, window_width, window_height, hwnd_dc, 0, 0, SRCCOPY):
            raise RuntimeError("Failed to capture the window.")

    bmi = BITMAPINFO()
    bmi.bmiHeader.biSize = ctypes.sizeof(BITMAPINFOHEADER)
    bmi.bmiHeader.biWidth = window_width
    bmi.bmiHeader.biHeight = -window_height
    bmi.bmiHeader.biPlanes = 1
    bmi.bmiHeader.biBitCount = 32
    bmi.bmiHeader.biCompression = BI_RGB

    buffer = ctypes.create_string_buffer(window_width * window_height * 4)
    bits = GetDIBits(mem_dc, bitmap, 0, window_height, buffer, ctypes.byref(bmi), DIB_RGB_COLORS)
    if bits == 0:
        raise RuntimeError("GetDIBits failed.")

    img = Image.frombuffer("RGBA", (window_width, window_height), buffer, "raw", "BGRA", 0, 1)

    DeleteObject(bitmap)
    DeleteDC(mem_dc)
    ReleaseDC(hwnd, hwnd_dc)

    return img


def compare_images(screenshot_image, template_path, threshold=0.90):
    screenshot_gray = cv2.cvtColor(np.array(screenshot_image), cv2.COLOR_RGBA2GRAY)
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)

    if template is None:
        raise RuntimeError("Failed to load template image for comparison.")

    sh, sw = screenshot_gray.shape[:2]
    th, tw = template.shape[:2]

    if th > sh or tw > sw:
        return False, 0.0

    result = cv2.matchTemplate(screenshot_gray, template, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, _ = cv2.minMaxLoc(result)
    return max_val >= threshold, max_val


def increment_number_in_file(file_path, increment_amount):
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read().strip()

    if not content:
        number = 0
    else:
        number = int(content)

    number += increment_amount

    with open(file_path, "w", encoding="utf-8") as f:
        f.write(str(number))

    return number


def read_number_from_file(file_path):
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read().strip()

    if not content:
        return 0

    return int(content)


def is_counter_file_numeric(file_path):
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read().strip()
        if not content:
            return True
        int(content)
        return True
    except Exception:
        return False


# =========================
# HOTKEY HELPERS
# =========================
def normalize_hotkey_display(hotkey):
    if not hotkey:
        return ""
    parts = [part.strip() for part in hotkey.replace("-", "+").split("+") if part.strip()]
    if not parts:
        return ""
    normalized = []
    modifier_map = {
        "ctrl": "Ctrl",
        "control": "Ctrl",
        "alt": "Alt",
        "shift": "Shift",
        "cmd": "Cmd",
        "command": "Cmd",
        "win": "Win",
        "windows": "Win",
    }
    for part in parts:
        key_lower = part.lower()
        if key_lower in modifier_map:
            normalized.append(modifier_map[key_lower])
        else:
            if len(part) == 1:
                normalized.append(part.upper())
            else:
                normalized.append(part.upper() if key_lower.startswith("f") and part[1:].isdigit() else part.title())
    return "+".join(normalized)


def hotkey_display_to_keyboard(hotkey):
    if not hotkey:
        return ""
    parts = [part.strip() for part in hotkey.replace("-", "+").split("+") if part.strip()]
    if not parts:
        return ""
    normalized = []
    modifier_map = {
        "ctrl": "ctrl",
        "control": "ctrl",
        "alt": "alt",
        "shift": "shift",
        "cmd": "command",
        "command": "command",
        "win": "windows",
        "windows": "windows",
    }
    for part in parts:
        key_lower = part.lower()
        if key_lower in modifier_map:
            normalized.append(modifier_map[key_lower])
        else:
            normalized.append(key_lower)
    return "+".join(normalized)


def load_hotkeys_config():
    hotkeys = DEFAULT_HOTKEYS.copy()
    global_enabled = False

    if not os.path.exists(HOTKEYS_CONFIG_PATH):
        return hotkeys, global_enabled

    with open(HOTKEYS_CONFIG_PATH, "r", encoding="utf-8") as f:
        for line in f:
            if ":" not in line:
                continue
            key, value = line.split(":", 1)
            key = key.strip().lower()
            value = value.strip()
            if key == "global_enabled":
                global_enabled = value == "1"
            elif key in hotkeys:
                hotkeys[key] = normalize_hotkey_display(value)

    return hotkeys, global_enabled


def save_hotkeys_config(hotkeys, global_enabled):
    lines = [
        f"global_enabled: {'1' if global_enabled else '0'}\n",
    ]
    for key in ("start_stop", "capture", "count_plus", "count_minus"):
        lines.append(f"{key}: {hotkeys.get(key, '')}\n")

    with open(HOTKEYS_CONFIG_PATH, "w", encoding="utf-8") as f:
        f.writelines(lines)


# =========================
# RPC HELPERS
# =========================
def rpc_read_config(path):
    cfg = {
        "target": "",
        "game": "",
        "icon": "",
        "odds": 8192,
        "application_id": None
    }

    with open(path, "r", encoding="cp1252") as f:
        for line in f:
            if ":" in line:
                k, v = line.split(":", 1)
                k = k.lower().strip()
                v = v.strip()
                if k == "odds":
                    cfg[k] = int(v)
                else:
                    cfg[k] = v

    return cfg


def rpc_find_game_configs():
    games = []
    if not os.path.isdir(RPC_CONFIG_FOLDER):
        return games

    for fname in os.listdir(RPC_CONFIG_FOLDER):
        if not fname.endswith(".txt"):
            continue
        path = os.path.join(RPC_CONFIG_FOLDER, fname)
        try:
            with open(path, "r", encoding="cp1252") as f:
                contents = f.read().lower()
                if "application_id:" in contents:
                    games.append(fname[:-4])
        except Exception:
            continue
    return games


def rpc_open_options(profile):
    if profile.rpc_window and profile.rpc_window.winfo_exists():
        profile.rpc_window.lift()
        return

    win = tk.Toplevel(profile.frame)
    apply_window_style(win)
    win.resizable(False, False)
    win.transient(profile.frame)
    win.grab_set()
    win.configure(bg=DARK_BG)

    tree_frame = tk.Frame(win)
    tree_frame.grid(row=0, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")

    scrollbar = ttk.Scrollbar(tree_frame)
    scrollbar.pack(side="right", fill="y")

    style = ttk.Style(win)
    style.configure(
        "Rpc.Treeview",
        font=(FONT_NAME, BASE_FONT_SIZE),
        rowheight=RPC_ICON_SIZE + 6
    )
    style.configure("Rpc.TCombobox", font=(FONT_NAME, BASE_FONT_SIZE))
    win.option_add("*TCombobox*Listbox.font", (FONT_NAME, BASE_FONT_SIZE))

    tree = ttk.Treeview(
        tree_frame,
        show="tree",
        selectmode="browse",
        yscrollcommand=scrollbar.set,
        height=6,
        style="Rpc.Treeview"
    )
    tree.pack(side="left", fill="both", expand=True)
    scrollbar.config(command=tree.yview)

    win.rpc_icons = []

    for game_id in rpc_find_game_configs():
        display_name = game_id
        icon_image = None
        config_path = os.path.join(RPC_CONFIG_FOLDER, f"{game_id}.txt")

        try:
            cfg = rpc_read_config(config_path)
            if cfg.get("game"):
                display_name = cfg["game"]

            icon_name = cfg.get("icon", "")
            if icon_name:
                icon_path = os.path.join(SCRIPT_FOLDER, "assets", "game_icon", f"{icon_name}.png")
                if os.path.isfile(icon_path):
                    image = Image.open(icon_path).resize((RPC_ICON_SIZE, RPC_ICON_SIZE), Image.LANCZOS)
                    icon_image = ImageTk.PhotoImage(image)
                    win.rpc_icons.append(icon_image)
        except Exception:
            pass

        tree.insert("", "end", iid=game_id, text=f"  {display_name}", image=icon_image)

    if profile.rpc_game_id:
        tree.selection_set(profile.rpc_game_id)

    tk.Label(win, text="Target Pokemon:").grid(row=1, column=0, padx=10, pady=(0, 6), sticky="e")
    target_entry = tk.Entry(win, width=28)
    target_entry.grid(row=1, column=1, padx=10, pady=(0, 6), sticky="w")
    target_entry.insert(0, profile.rpc_target or "")

    suffix_to_label = {suffix: label for label, suffix in RPC_COUNTER_OPTIONS}
    label_to_suffix = {label: suffix for label, suffix in RPC_COUNTER_OPTIONS}
    selected_label = suffix_to_label.get(profile.rpc_counter_suffix, "Default / Other")

    tk.Label(win, text="Counter Type:").grid(row=2, column=0, padx=10, pady=(0, 6), sticky="e")
    counter_type_var = tk.StringVar(value=selected_label)
    counter_type_menu = ttk.Combobox(
        win,
        textvariable=counter_type_var,
        values=[label for label, _ in RPC_COUNTER_OPTIONS],
        state="readonly",
        width=20,
        style="Rpc.TCombobox"
    )
    counter_type_menu.grid(row=2, column=1, padx=10, pady=(0, 6), sticky="w")

    tk.Label(win, text="Odds:").grid(row=3, column=0, padx=10, pady=(0, 6), sticky="e")
    odds_entry = tk.Entry(win, width=10)
    odds_entry.grid(row=3, column=1, padx=10, pady=(0, 6), sticky="w")
    odds_entry.insert(0, str(profile.rpc_odds))

    def save_fields():
        target = target_entry.get().strip()
        odds_text = odds_entry.get().strip()
        try:
            odds = int(odds_text)
        except ValueError:
            messagebox.showerror("Invalid Odds", "Odds must be a number like 8192.")
            return False

        selection = tree.selection()
        if not selection:
            messagebox.showwarning("Select Game", "Please select a game.")
            return False

        game_id = selection[0]
        profile.rpc_game_id = game_id
        profile.rpc_target = target
        profile.rpc_odds = odds

        selected_suffix = label_to_suffix.get(counter_type_var.get(), "Encounters")
        profile.rpc_counter_suffix = selected_suffix
        profile.update_config_value(CONFIG_KEY_RPC_SUFFIX, selected_suffix)

        profile.update_config_value(CONFIG_KEY_RPC_GAME, game_id)
        profile.update_config_value(CONFIG_KEY_RPC_TARGET, target)
        profile.update_config_value(CONFIG_KEY_RPC_ODDS, odds)
        profile.mark_dirty()
        return True

    def apply_and_close():
        if save_fields():
            win.destroy()
            profile.rpc_window = None

    def close_rpc():
        win.destroy()
        profile.rpc_window = None

    tk.Button(
        win,
        text="Apply",
        command=apply_and_close,
        padx=BUTTON_PADX,
        pady=BUTTON_PADY,
        height=BUTTON_HEIGHT
    ).grid(row=4, column=0, padx=(10, 4), pady=10, sticky="e")
    tk.Button(
        win,
        text="Close",
        command=close_rpc,
        padx=BUTTON_PADX,
        pady=BUTTON_PADY,
        height=BUTTON_HEIGHT
    ).grid(row=4, column=1, padx=(4, 10), pady=10, sticky="w")
    win.protocol("WM_DELETE_WINDOW", close_rpc)

    center_window(win, profile.frame.winfo_toplevel())


def rpc_shiny_confidence(enc, odds):
    p = 1 / odds
    return 1 - (1 - p) ** enc, "▲" if enc >= odds else "▼"


# =========================
# HOTKEY MANAGER
# =========================
class HotkeyManager:
    def __init__(self, root, get_active_profile):
        self.root = root
        self.get_active_profile = get_active_profile
        self.hotkeys = DEFAULT_HOTKEYS.copy()
        self.global_enabled = False
        self._global_handles = []
        self._local_binding = None
        self.suspended = False

    def _clear_global_hotkeys(self):
        if keyboard is None:
            self._global_handles = []
            return
        for handle in self._global_handles:
            try:
                keyboard.remove_hotkey(handle)
            except Exception:
                pass
        self._global_handles = []

    def _register_global_hotkeys(self):
        self._clear_global_hotkeys()
        if self.suspended or not self.global_enabled or keyboard is None:
            return

        def add_hotkey(key, callback):
            if not key:
                return
            key_for_keyboard = hotkey_display_to_keyboard(key)
            if not key_for_keyboard:
                return
            handle = keyboard.add_hotkey(key_for_keyboard, callback)
            self._global_handles.append(handle)

        add_hotkey(self.hotkeys.get("start_stop", ""), self.trigger_start_stop)
        add_hotkey(self.hotkeys.get("capture", ""), self.trigger_capture)
        add_hotkey(self.hotkeys.get("count_plus", ""), self.trigger_count_plus)
        add_hotkey(self.hotkeys.get("count_minus", ""), self.trigger_count_minus)

    def suspend(self):
        self.suspended = True
        self._clear_global_hotkeys()

    def resume(self):
        self.suspended = False
        self._register_global_hotkeys()

    def _build_event_hotkey(self, event):
        modifiers = []
        if event.state & 0x0004:
            modifiers.append("Ctrl")
        if event.state & 0x0001:
            modifiers.append("Shift")
        if event.state & 0x0008:
            modifiers.append("Alt")

        key = event.keysym
        if len(key) == 1:
            key = key.upper()
        else:
            key = key.upper() if key.lower().startswith("f") and key[1:].isdigit() else key.title()

        return "+".join(modifiers + [key])

    def _local_keypress(self, event):
        if self.suspended or self.global_enabled:
            return
        pressed = self._build_event_hotkey(event)
        if pressed == self.hotkeys.get("start_stop", ""):
            self.trigger_start_stop()
        elif pressed == self.hotkeys.get("capture", ""):
            self.trigger_capture()
        elif pressed == self.hotkeys.get("count_plus", ""):
            self.trigger_count_plus()
        elif pressed == self.hotkeys.get("count_minus", ""):
            self.trigger_count_minus()

    def register_local_hotkeys(self):
        if self._local_binding is None:
            self._local_binding = self.root.bind_all("<KeyPress>", self._local_keypress)

    def set_hotkeys(self, hotkeys):
        self.hotkeys = {
            key: normalize_hotkey_display(value)
            for key, value in hotkeys.items()
        }
        self._register_global_hotkeys()

    def set_global_enabled(self, enabled):
        if enabled and keyboard is None:
            messagebox.showerror("Hotkeys Unavailable", "Global hotkeys require the 'keyboard' package.")
            self.global_enabled = False
            self._register_global_hotkeys()
            return False

        self.global_enabled = enabled
        self._register_global_hotkeys()
        return True

    def trigger_start_stop(self):
        if self.suspended:
            return
        profile = self.get_active_profile()
        if profile:
            profile.on_toggle_start()

    def trigger_capture(self):
        if self.suspended:
            return
        profile = self.get_active_profile()
        if profile:
            profile.on_capture_reference()

    def trigger_count_plus(self):
        if self.suspended:
            return
        profile = self.get_active_profile()
        if profile:
            profile.on_manual_adjust(1)

    def trigger_count_minus(self):
        if self.suspended:
            return
        profile = self.get_active_profile()
        if profile:
            profile.on_manual_adjust(-1)


# =========================
# PROFILE TAB CLASS
# =========================
class ProfileTab:
    def __init__(self, parent, profile_index):
        self.notebook = parent
        self.profile_index = profile_index
        self.default_tab_name = f"Profile {profile_index}"
        self.config_path = os.path.join("config", f"config{profile_index}.txt")

        self.selected_image_path = ""
        self.selected_text_path = ""
        self.last_match_time = 0.0
        self.is_running = False
        self.configure_window = None
        self.test_window = None
        self.capture_window = None
        self.rpc_window = None
        self._drag_offset = (0, 0)
        self._test_drag_offset = (0, 0)
        self._dirty = False
        self._autosave_after_id = None

        self.rpc = None
        self.rpc_thread = None
        self.rpc_stop_event = threading.Event()
        self.rpc_game_id = ""
        self.rpc_target = ""
        self.rpc_odds = 8192
        self.rpc_is_running = False
        self.rpc_enabled = False
        self.rpc_last_stop_time = 0.0
        self.rpc_counter_suffix = "Encounters"

        self.auto_count_var = tk.BooleanVar(value=True)

        self.image_path_var = tk.StringVar()
        self.text_path_var = tk.StringVar()
        self.title_var = tk.StringVar()
        self.profile_name_var = tk.StringVar()
        self.increment_var = tk.StringVar()
        self._last_text_path = ""
        self._loading_config = False

        self.image_path_var.trace_add("write", self._on_image_path_change)
        self.text_path_var.trace_add("write", self._on_text_path_change)
        self.title_var.trace_add("write", self._on_title_change)
        self.profile_name_var.trace_add("write", self._on_profile_name_change)
        self.increment_var.trace_add("write", self._on_increment_change)
        self.auto_count_var.trace_add("write", self._on_auto_count_toggle)

        self.frame = tk.Frame(parent, bg=DARK_BG, highlightthickness=0, bd=0)

        self.build_ui()
        self.schedule_autosave()
        self._update_manual_buttons()
        self.set_settings_state(True)

    # ---------- Autosave helpers ----------
    def mark_dirty(self):
        if not self._loading_config:
            self._dirty = True

    def schedule_autosave(self):
        if self._autosave_after_id is not None:
            self.frame.after_cancel(self._autosave_after_id)
        self._autosave_after_id = self.frame.after(2000, self._autosave_check)

    def _autosave_check(self):
        if self._dirty:
            self.save_settings_silent()
            self._dirty = False
        self.schedule_autosave()

    def _sanitize_increment_value(self, value):
        if value < MIN_INCREMENT:
            return MIN_INCREMENT
        if value > MAX_INCREMENT:
            return MAX_INCREMENT
        return value

    def save_settings_silent(self):
        profile_name = self.profile_name_var.get().strip()[:PROFILE_NAME_MAX_LENGTH]
        if not profile_name:
            profile_name = self.default_tab_name
            self.profile_name_var.set(profile_name)

        title = self.title_var.get().strip()
        cooldown = int(self.cooldown_var.get())
        frequency = float(self.frequency_var.get())
        threshold = float(self.threshold_var.get())
        increment_amount = self.increment_var.get().strip() or str(MIN_INCREMENT)

        self.update_config_value(CONFIG_KEY_PROFILE_NAME, profile_name)
        self.update_config_value(CONFIG_KEY_TITLE, title)
        self.update_config_value(CONFIG_KEY_COOLDOWN, cooldown)
        self.update_config_value(CONFIG_KEY_FREQUENCY, frequency)
        self.update_config_value(CONFIG_KEY_THRESHOLD, threshold)
        self.update_config_value(CONFIG_KEY_IMAGE, self.selected_image_path)
        self.update_config_value(CONFIG_KEY_TEXT, self.selected_text_path)
        self.update_config_value(CONFIG_KEY_INCREMENT, increment_amount)
        self.update_config_value(CONFIG_KEY_RPC_ENABLED, "1" if self.rpc_enabled else "0")
        self.update_config_value(CONFIG_KEY_RPC_SUFFIX, self.rpc_counter_suffix)

        self.set_tab_title()

    # ---------- Config helpers ----------
    def load_config_value(self, key, default_value):
        if not os.path.exists(self.config_path):
            return default_value

        with open(self.config_path, "r", encoding="utf-8") as f:
            for line in f:
                if line.lower().startswith(key):
                    return line.split(":", 1)[1].strip()

        return default_value

    def update_config_value(self, key, value):
        lines = []
        found = False

        if os.path.exists(self.config_path):
            with open(self.config_path, "r", encoding="utf-8") as f:
                lines = f.readlines()

        for i, line in enumerate(lines):
            if line.lower().startswith(key):
                lines[i] = f"{key} {value}\n"
                found = True
                break

        if not found:
            lines.append(f"{key} {value}\n")

        os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
        with open(self.config_path, "w", encoding="utf-8") as f:
            f.writelines(lines)

    def _get_increment_amount(self):
        try:
            value = int(self.increment_var.get().strip() or str(MIN_INCREMENT))
        except ValueError:
            return MIN_INCREMENT
        return self._sanitize_increment_value(value)

    def _update_manual_buttons(self):
        if self.auto_count_var.get():
            self.btn_decrement.config(text="-1")
            self.btn_increment.config(text="+1")
        else:
            increment = self._get_increment_amount()
            self.btn_decrement.config(text=f"-{increment}")
            self.btn_increment.config(text=f"+{increment}")

    def _on_auto_count_toggle(self, *_):
        self._update_manual_buttons()
        self.set_settings_state(not self.is_running)

    def _on_image_path_change(self, *_):
        self.selected_image_path = self.image_path_var.get().strip()
        self.mark_dirty()

    def _on_text_path_change(self, *_):
        new_path = self.text_path_var.get().strip()
        if not self._loading_config and self._last_text_path:
            if os.path.abspath(new_path) != os.path.abspath(self._last_text_path):
                self.reset_rpc_options()

        self.selected_text_path = new_path
        self._last_text_path = new_path
        self.mark_dirty()
        if new_path and os.path.isfile(new_path):
            try:
                current_value = read_number_from_file(new_path)
                self.lbl_current_count.config(text=str(current_value))
            except Exception:
                self.lbl_current_count.config(text="(invalid)")

    def _on_title_change(self, *_):
        self.mark_dirty()

    def _on_profile_name_change(self, *_):
        current = self.profile_name_var.get().strip()
        if len(current) > PROFILE_NAME_MAX_LENGTH:
            current = current[:PROFILE_NAME_MAX_LENGTH]
            self.profile_name_var.set(current)
        if not current:
            self.profile_name_var.set(self.default_tab_name)
        self.set_tab_title()
        self.mark_dirty()

    def _on_increment_change(self, *_):
        try:
            value = int(self.increment_var.get().strip() or str(MIN_INCREMENT))
        except ValueError:
            value = MIN_INCREMENT
        value = self._sanitize_increment_value(value)
        if self.increment_var.get().strip() != str(value):
            self.increment_var.set(str(value))
        self.mark_dirty()
        self._update_manual_buttons()

    def reset_rpc_options(self):
        if self.rpc_is_running:
            self.stop_broadcast()

        self.rpc_game_id = ""
        self.rpc_target = ""
        self.rpc_odds = 8192
        self.rpc_enabled = False
        self.rpc_enabled_var.set(False)
        self.rpc_counter_suffix = "Encounters"

        self.update_config_value(CONFIG_KEY_RPC_GAME, "")
        self.update_config_value(CONFIG_KEY_RPC_TARGET, "")
        self.update_config_value(CONFIG_KEY_RPC_ODDS, "")
        self.update_config_value(CONFIG_KEY_RPC_ENABLED, "0")
        self.update_config_value(CONFIG_KEY_RPC_SUFFIX, self.rpc_counter_suffix)
        self.mark_dirty()

    # ---------- Configure window dragging ----------
    def _on_configure_drag_start(self, event):
        if isinstance(event.widget, tk.Scale):
            return
        self._drag_offset = (event.x_root, event.y_root)

    def _on_configure_drag(self, event):
        if isinstance(event.widget, tk.Scale):
            return
        if not self.configure_window or not self.configure_window.winfo_exists():
            return
        x = self.configure_window.winfo_x() + (event.x_root - self._drag_offset[0])
        y = self.configure_window.winfo_y() + (event.y_root - self._drag_offset[1])
        self.configure_window.geometry(f"+{x}+{y}")
        self._drag_offset = (event.x_root, event.y_root)

    # ---------- Test window dragging ----------
    def _on_test_drag_start(self, event):
        if isinstance(event.widget, tk.Scale):
            return
        self._test_drag_offset = (event.x_root, event.y_root)

    def _on_test_drag(self, event):
        if isinstance(event.widget, tk.Scale):
            return
        if not self.test_window or not self.test_window.winfo_exists():
            return
        x = self.test_window.winfo_x() + (event.x_root - self._test_drag_offset[0])
        y = self.test_window.winfo_y() + (event.y_root - self._test_drag_offset[1])
        self.test_window.geometry(f"+{x}+{y}")
        self._test_drag_offset = (event.x_root, event.y_root)

    # ---------- Window positioning ----------
    def _position_popup_near_root(self, window):
        root = self.frame.winfo_toplevel()
        root.update_idletasks()
        x = root.winfo_rootx() + 40
        y = root.winfo_rooty() + 60
        window.geometry(f"+{x}+{y}")

    def on_pick_window(self):
        picker = tk.Toplevel(self.frame)
        apply_window_style(picker)
        picker.resizable(False, False)
        picker.transient(self.frame.winfo_toplevel())
        picker.grab_set()

        frame = tk.Frame(picker, bg=DARK_BG)
        frame.pack(padx=10, pady=10, fill="both", expand=True)

        listbox = tk.Listbox(frame, width=60, height=12)
        listbox.pack(side="left", fill="both", expand=True)

        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=listbox.yview)
        scrollbar.pack(side="right", fill="y")
        listbox.config(yscrollcommand=scrollbar.set)

        def refresh_list():
            listbox.delete(0, tk.END)
            for title in list_window_titles():
                listbox.insert(tk.END, title)

        def apply_selection():
            selection = listbox.curselection()
            if not selection:
                return
            chosen = listbox.get(selection[0])
            self.title_var.set(chosen)
            picker.destroy()

        refresh_list()

        button_row = tk.Frame(picker, bg=DARK_BG)
        button_row.pack(padx=10, pady=(0, 10), fill="x")

        tk.Button(
            button_row,
            text="Refresh",
            command=refresh_list,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        ).pack(side="left", padx=(0, 4))
        tk.Button(
            button_row,
            text="Use Selected",
            command=apply_selection,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        ).pack(side="left", padx=4)
        tk.Button(
            button_row,
            text="Close",
            command=picker.destroy,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        ).pack(side="left", padx=(4, 0))

        center_window(picker, self.frame.winfo_toplevel())

    # ---------- UI ----------
    def build_ui(self):
        frame = self.frame

        container = tk.Frame(frame, bg=DARK_BG, width=TABLE_WIDTH, height=TABLE_HEIGHT)
        container.pack(padx=10, pady=10)
        container.pack_propagate(False)

        def make_row(pady=5):
            row = tk.Frame(container, bg=DARK_BG)
            row.pack(pady=pady, anchor="w")
            return row

        # Capture Window
        row_title_label = make_row(pady=0)
        self.label_title = tk.Label(row_title_label, text="Capture Window:", font=(FONT_NAME, BASE_FONT_SIZE, "bold"))
        self.label_title.pack(side="left", padx=0)

        row_title = make_row()
        self.entry_title = tk.Entry(row_title, width=40, textvariable=self.title_var)
        self.entry_title.pack(side="left", padx=0)
        self.btn_pick_window = tk.Button(
            row_title,
            text="Window List",
            command=self.on_pick_window,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT,
            font=(FONT_NAME, SMALL_BUTTON_FONT_SIZE)
        )
        self.btn_pick_window.pack(side="left", padx=(4, 0))

        spacer_capture_ref = tk.Frame(container, bg=DARK_BG, height=10)
        spacer_capture_ref.pack(pady=6)

        # Reference Frame
        row_image_label = make_row(pady=0)
        self.lbl_image = tk.Label(row_image_label, text="Reference Frame:", font=(FONT_NAME, BASE_FONT_SIZE, "bold"))
        self.lbl_image.pack(side="left", padx=0)

        row_image = make_row()
        self.entry_image_path = tk.Entry(row_image, width=40, textvariable=self.image_path_var)
        self.entry_image_path.pack(side="left", padx=0)
        self.btn_browse_image = tk.Button(
            row_image,
            text="Browse",
            command=self.on_browse_image,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT,
            font=(FONT_NAME, SMALL_BUTTON_FONT_SIZE)
        )
        self.btn_browse_image.pack(side="left", padx=(4, 0))
        self.btn_capture_image = tk.Button(
            row_image,
            text="Capture",
            command=self.on_capture_reference,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT,
            font=(FONT_NAME, SMALL_BUTTON_FONT_SIZE)
        )
        self.btn_capture_image.pack(side="left", padx=(4, 0))

        spacer_ref_counter = tk.Frame(container, bg=DARK_BG, height=18)
        spacer_ref_counter.pack(pady=10)

        # Counter File
        row_text_label = make_row(pady=0)
        self.lbl_text = tk.Label(row_text_label, text="Counter File:", font=(FONT_NAME, BASE_FONT_SIZE, "bold"))
        self.lbl_text.pack(side="left", padx=0)

        row_text = make_row()
        self.entry_text_path = tk.Entry(row_text, width=40, textvariable=self.text_path_var)
        self.entry_text_path.pack(side="left", padx=0)
        self.btn_browse_text = tk.Button(
            row_text,
            text="Browse",
            command=self.on_browse_text,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT,
            font=(FONT_NAME, SMALL_BUTTON_FONT_SIZE)
        )
        self.btn_browse_text.pack(side="left", padx=(4, 0))

        spacer_counter_increment = tk.Frame(container, bg=DARK_BG, height=10)
        spacer_counter_increment.pack(pady=6)

        # Increment + Counter Row
        row_counter_increment = make_row()
        self.btn_decrement = tk.Button(
            row_counter_increment,
            text="-1",
            width=6,
            height=COUNTER_BUTTON_HEIGHT,
            font=(FONT_NAME, BASE_FONT_SIZE, "bold"),
            command=lambda: self.on_manual_adjust(-1)
        )
        self.btn_decrement.pack(side="left", padx=(0, 4))
        self.lbl_current_count = tk.Label(
            row_counter_increment,
            text="0",
            font=(FONT_NAME, LARGE_FONT_SIZE, "bold"),
            width=7,
            relief="solid",
            bd=1,
            padx=8,
            pady=2
        )
        self.lbl_current_count.pack(side="left", padx=0)
        self.btn_increment = tk.Button(
            row_counter_increment,
            text="+1",
            width=6,
            height=COUNTER_BUTTON_HEIGHT,
            font=(FONT_NAME, BASE_FONT_SIZE, "bold"),
            command=lambda: self.on_manual_adjust(1)
        )
        self.btn_increment.pack(side="left", padx=(4, 12))

        self.lbl_increment = tk.Label(row_counter_increment, text="Increment:", font=(FONT_NAME, BASE_FONT_SIZE, "bold"))
        self.lbl_increment.pack(side="left", padx=(0, 4))
        self.entry_increment = tk.Entry(row_counter_increment, width=4, textvariable=self.increment_var, justify="center")
        self.entry_increment.pack(side="left", padx=0)

        spacer_increment_to_rpc = tk.Frame(container, bg=DARK_BG, height=14)
        spacer_increment_to_rpc.pack(pady=10)

        # Rest of UI (unchanged)
        row_rpc_enable = make_row()
        self.auto_count_check = tk.Checkbutton(
            row_rpc_enable,
            text="Enable Auto-Count",
            variable=self.auto_count_var,
            command=self._on_auto_count_toggle
        )
        self.auto_count_check.pack(side="left", padx=(0, 8))

        self.rpc_enabled_var = tk.BooleanVar(value=False)
        self.rpc_check = tk.Checkbutton(
            row_rpc_enable,
            text="Enable RPC",
            variable=self.rpc_enabled_var,
            command=self.on_toggle_rpc_enabled
        )
        self.rpc_check.pack(side="left", padx=0)

        row_config_buttons = make_row()
        self.btn_hotkeys = tk.Button(
            row_config_buttons,
            text="Hotkeys",
            command=open_hotkeys_window,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        )
        self.btn_hotkeys.pack(side="left", padx=(0, 4))
        self.btn_configure = tk.Button(
            row_config_buttons,
            text="Configure Sensitivity",
            command=self.open_configure_window,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        )
        self.btn_configure.pack(side="left", padx=(0, 4))
        self.btn_rpc = tk.Button(
            row_config_buttons,
            text="Configure RPC",
            command=self.on_rpc_options,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        )
        self.btn_rpc.pack(side="left", padx=(4, 4))

        self.btn_start = tk.Button(
            row_config_buttons,
            text="Start",
            command=self.on_toggle_start,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        )
        self.btn_start.pack(side="left", padx=(4, 0))

        spacer = tk.Frame(container, bg=DARK_BG, height=5)
        spacer.pack(pady=5)

        self.cooldown_var = tk.IntVar(value=5)
        self.frequency_var = tk.DoubleVar(value=0.5)
        self.threshold_var = tk.DoubleVar(value=0.9)

        self.cooldown_var.trace_add("write", lambda *_: self.mark_dirty())
        self.frequency_var.trace_add("write", lambda *_: self.mark_dirty())
        self.threshold_var.trace_add("write", lambda *_: self.mark_dirty())

    # ---------- State helpers ----------
    def set_settings_state(self, enabled):
        auto_controls_state = "normal" if enabled and self.auto_count_var.get() else "disabled"
        state = "normal" if enabled else "disabled"

        self.entry_title.config(state=auto_controls_state)
        self.btn_pick_window.config(state=auto_controls_state)
        self.entry_image_path.config(state=auto_controls_state)
        self.btn_browse_image.config(state=auto_controls_state)
        self.btn_capture_image.config(state=auto_controls_state)
        self.btn_configure.config(state=auto_controls_state)

        self.entry_text_path.config(state=state)
        self.btn_browse_text.config(state=state)
        self.entry_increment.config(state=state)
        self.rpc_check.config(state=state)
        self.btn_rpc.config(state=state)
        self.auto_count_check.config(state=state)
        # Keep Start/Stop enabled so Stop is clickable.

        if self.configure_window and self.configure_window.winfo_exists():
            widgets = self.configure_window.winfo_children()
            for widget in widgets:
                if isinstance(widget, tk.Scale):
                    widget.config(state=auto_controls_state)

    def set_tab_title(self):
        name = self.profile_name_var.get().strip() or self.default_tab_name
        self.notebook.tab(self.frame, text=name)

    def validate_required_inputs(self, show_popup=True):
        increment_text = self.entry_increment.get().strip()

        if not self.selected_text_path:
            if show_popup:
                messagebox.showerror("Text File Missing", "No text file selected.")
            return False, None

        if not os.path.isfile(self.selected_text_path):
            if show_popup:
                messagebox.showerror("Text File Missing", "Selected text file no longer exists.")
            return False, None

        if not is_counter_file_numeric(self.selected_text_path):
            if show_popup:
                messagebox.showerror(
                    "Invalid Counter File",
                    "Counter file contains non-numeric text. Please fix the file before starting."
                )
            return False, None

        if not self.auto_count_var.get():
            return True, None

        if not self.selected_image_path:
            if show_popup:
                messagebox.showerror("Image Missing", "No image selected.")
            return False, None

        if not os.path.isfile(self.selected_image_path):
            if show_popup:
                messagebox.showerror("Image Missing", "Selected image file no longer exists.")
            return False, None

        try:
            increment_amount = int(increment_text)
        except ValueError:
            if show_popup:
                messagebox.showerror("Invalid Increment", "Increment amount must be a number between 1 and 99.")
            return False, None

        if not (MIN_INCREMENT <= increment_amount <= MAX_INCREMENT):
            if show_popup:
                messagebox.showerror("Invalid Increment", "Increment amount must be between 1 and 99.")
            return False, None

        return True, increment_amount

    # ---------- UI actions ----------
    def on_profile_name_change(self, event=None):
        pass

    def on_browse_image(self):
        path = filedialog.askopenfilename(
            title="Choose Image to Compare",
            filetypes=[("Image Files", "*.png;*.jpg;*.jpeg;*.bmp")]
        )
        if path:
            self.image_path_var.set(path)

    def on_browse_text(self):
        path = filedialog.askopenfilename(
            title="Choose Text File",
            filetypes=[("Text Files", "*.txt")]
        )
        if path:
            self.text_path_var.set(path)

    def on_capture_reference(self):
        if self.capture_window and self.capture_window.winfo_exists():
            self.capture_window.lift()
            return

        title = self.title_var.get().strip()
        if not title:
            messagebox.showerror("Invalid Window Title", "Please enter an OBS window title.")
            return

        hwnd = find_window_by_title_exact(title)
        if not hwnd:
            messagebox.showerror("Invalid Window Title", "No visible window found with that title.")
            return

        if is_window_minimized(hwnd):
            messagebox.showerror("Window Minimized", "OBS window is minimized. Please restore it before capturing.")
            return

        try:
            screenshot_img = grab_window_image(hwnd)
        except Exception as exc:
            messagebox.showerror("Capture Error", f"Failed to capture the window.\n{exc}")
            return

        self.capture_window = tk.Toplevel(self.frame)
        apply_window_style(self.capture_window)
        crop_win = self.capture_window
        crop_win.resizable(False, False)
        crop_win.transient(self.frame.winfo_toplevel())

        max_w, max_h = 900, 600
        orig_w, orig_h = screenshot_img.size
        scale = min(max_w / orig_w, max_h / orig_h, 1.0)
        display_w = max(1, int(orig_w * scale))
        display_h = max(1, int(orig_h * scale))
        display_img = screenshot_img if scale == 1.0 else screenshot_img.resize((display_w, display_h), Image.LANCZOS)

        tk_img = ImageTk.PhotoImage(display_img)

        canvas = tk.Canvas(crop_win, width=display_w, height=display_h, highlightthickness=0)
        canvas.pack(padx=10, pady=10)
        canvas.create_image(0, 0, anchor="nw", image=tk_img)
        canvas.image = tk_img

        crop_state = {"start": None, "rect": None, "box": None}

        def on_press(event):
            crop_state["start"] = (event.x, event.y)
            if crop_state["rect"]:
                canvas.delete(crop_state["rect"])
                crop_state["rect"] = None

        def on_drag(event):
            if not crop_state["start"]:
                return
            x0, y0 = crop_state["start"]
            x1, y1 = event.x, event.y
            if crop_state["rect"]:
                canvas.coords(crop_state["rect"], x0, y0, x1, y1)
            else:
                crop_state["rect"] = canvas.create_rectangle(x0, y0, x1, y1, outline="#00ff99", width=2)

        def on_release(event):
            if not crop_state["start"]:
                return
            x0, y0 = crop_state["start"]
            x1, y1 = event.x, event.y
            crop_state["box"] = (x0, y0, x1, y1)

        canvas.bind("<ButtonPress-1>", on_press)
        canvas.bind("<B1-Motion>", on_drag)
        canvas.bind("<ButtonRelease-1>", on_release)

        def save_crop():
            if not crop_state["box"]:
                messagebox.showwarning("No Crop", "Please drag to select a crop area.")
                return

            x0, y0, x1, y1 = crop_state["box"]
            left = min(x0, x1)
            right = max(x0, x1)
            top = min(y0, y1)
            bottom = max(y0, y1)

            if right - left < 2 or bottom - top < 2:
                messagebox.showwarning("Invalid Crop", "Crop area is too small.")
                return

            scale_x = orig_w / display_w
            scale_y = orig_h / display_h

            crop_left = max(0, int(left * scale_x))
            crop_right = min(orig_w, int(right * scale_x))
            crop_top = max(0, int(top * scale_y))
            crop_bottom = min(orig_h, int(bottom * scale_y))

            if crop_right <= crop_left or crop_bottom <= crop_top:
                messagebox.showwarning("Invalid Crop", "Crop area is invalid.")
                return

            cropped = screenshot_img.crop((crop_left, crop_top, crop_right, crop_bottom))
            filename = f"profile_{self.profile_index}.png"
            path = os.path.join(REFERENCES_FOLDER, filename)
            try:
                cropped.save(path, format="PNG")
            except Exception as exc:
                messagebox.showerror("Save Error", f"Failed to save the reference image.\n{exc}")
                return

            self.image_path_var.set(path)
            self.capture_window.destroy()
            self.capture_window = None

        def close_capture():
            self.capture_window.destroy()
            self.capture_window = None

        buttons = tk.Frame(crop_win, bg=DARK_BG)
        buttons.pack(padx=10, pady=(0, 10), fill="x")

        tk.Button(
            buttons,
            text="Save Crop",
            command=save_crop,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        ).pack(side="left", padx=(0, 4))
        tk.Button(
            buttons,
            text="Cancel",
            command=close_capture,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        ).pack(side="left", padx=(4, 0))
        crop_win.protocol("WM_DELETE_WINDOW", close_capture)

        center_window(crop_win, self.frame.winfo_toplevel())

    def on_test_image(self):
        if self.test_window and self.test_window.winfo_exists():
            self.test_window.lift()
            return

        title = self.title_var.get().strip()
        if not title:
            messagebox.showerror("Invalid Window Title", "Please enter an OBS window title.")
            return

        if not self.selected_image_path:
            messagebox.showerror("Image Missing", "No image selected.")
            return

        if not os.path.isfile(self.selected_image_path):
            messagebox.showerror("Image Missing", "Selected image file no longer exists.")
            return

        self.test_window = tk.Toplevel(self.frame)
        apply_window_style(self.test_window)
        self.test_window.resizable(False, False)
        self._position_popup_near_root(self.test_window)

        self.test_window.bind("<ButtonPress-1>", self._on_test_drag_start)
        self.test_window.bind("<B1-Motion>", self._on_test_drag)

        label = tk.Label(self.test_window, text="Checking...", padx=20, pady=20)
        label.pack()

        is_active = {"running": True}

        def on_close():
            is_active["running"] = False
            self.test_window.destroy()
            self.test_window = None

        self.test_window.protocol("WM_DELETE_WINDOW", on_close)

        def update_result():
            if not is_active["running"]:
                return

            hwnd = find_window_by_title_exact(title)
            if not hwnd:
                label.config(text="❌ Window not found.")
            elif is_window_minimized(hwnd):
                label.config(text="⚠️ Window is minimized.")
            else:
                try:
                    screenshot_img = grab_window_image(hwnd)
                    is_match, confidence = compare_images(
                        screenshot_img, self.selected_image_path, threshold=float(self.threshold_var.get())
                    )
                    percent = max(0.0, min(1.0, confidence)) * 100
                    status = "✅ Image detected!" if is_match else "❌ Image not detected."
                    label.config(text=f"{status}\nConfidence: {percent:.1f}%")
                except Exception as exc:
                    label.config(text=f"⚠️ Error: {exc}")

            self.test_window.after(200, update_result)

        update_result()

    def on_save_settings(self):
        self.save_settings_silent()
        messagebox.showinfo("Saved", f"Settings saved to {os.path.basename(self.config_path)}")

    def on_toggle_rpc_enabled(self):
        self.rpc_enabled = self.rpc_enabled_var.get()
        self.update_config_value(CONFIG_KEY_RPC_ENABLED, "1" if self.rpc_enabled else "0")
        self.mark_dirty()

    def on_toggle_start(self):
        if not self.is_running:
            is_valid, _ = self.validate_required_inputs(show_popup=True)
            if not is_valid:
                return

            if self.auto_count_var.get():
                title = self.title_var.get().strip()
                if not title:
                    messagebox.showerror("Invalid Window Title", "Please enter an OBS window title.")
                    return

                hwnd = find_window_by_title_exact(title)
                if not hwnd:
                    messagebox.showerror("Invalid Window Title", "No visible window found with that title.")
                    return

                if is_window_minimized(hwnd):
                    messagebox.showerror("Window Minimized", "OBS window is minimized. Please restore it before starting.")
                    return

            if self.rpc_enabled:
                if time.monotonic() - self.rpc_last_stop_time < 30:
                    messagebox.showwarning(
                        "RPC Cooling Down",
                        "Previous RPC connection is still closing, please wait 30 seconds and try again or disable RPC."
                    )
                    return
                if ACTIVE_BROADCAST_PROFILE is not None and ACTIVE_BROADCAST_PROFILE != self.profile_index:
                    messagebox.showwarning("Broadcast Active", "Another profile is already broadcasting.")
                    return
                if not self.rpc_game_id:
                    messagebox.showwarning("RPC Settings Missing", "Please configure RPC Options first.")
                    return
                self.start_broadcast_async(self.rpc_game_id, self.rpc_target, self.rpc_odds)

        self.is_running = not self.is_running
        if self.is_running:
            self.btn_start.config(text="Stop")
            self.set_settings_state(False)
            if self.auto_count_var.get():
                self.auto_check_loop()
        else:
            self.btn_start.config(text="Start")
            self.set_settings_state(True)
            if self.rpc_is_running:
                self.stop_broadcast()

    def on_manual_adjust(self, delta):
        if not self.selected_text_path:
            messagebox.showwarning("Missing Text File", "Please choose a .txt file first.")
            return
        if not os.path.isfile(self.selected_text_path):
            messagebox.showerror("Text File Missing", "Selected text file no longer exists.")
            return

        if self.auto_count_var.get():
            amount = delta
        else:
            amount = delta * self._get_increment_amount()

        try:
            new_value = increment_number_in_file(self.selected_text_path, amount)
            self.lbl_current_count.config(text=str(new_value))
        except Exception:
            self.lbl_current_count.config(text="(invalid)")

    def on_reset_count(self):
        if not self.selected_text_path:
            messagebox.showwarning("Missing Text File", "Please choose a .txt file first.")
            return
        if not os.path.isfile(self.selected_text_path):
            messagebox.showerror("Text File Missing", "Selected text file no longer exists.")
            return
        if not messagebox.askyesno("Reset Counter", "Reset the count to 0?"):
            return
        try:
            with open(self.selected_text_path, "w", encoding="utf-8") as f:
                f.write("0")
            self.lbl_current_count.config(text="0")
        except Exception:
            self.lbl_current_count.config(text="(invalid)")

    def on_rpc_options(self):
        if Presence is None:
            messagebox.showerror("Missing Dependency", "pypresence is not installed.")
            return

        rpc_open_options(self)

    def start_broadcast_async(self, game_id, target, odds):
        global ACTIVE_BROADCAST_PROFILE

        config_path = os.path.join(RPC_CONFIG_FOLDER, f"{game_id}.txt")
        cfg = rpc_read_config(config_path)

        if not cfg.get("application_id"):
            messagebox.showerror("Invalid Config", "Missing application_id in RPC config.")
            return

        if not self.selected_text_path or not os.path.isfile(self.selected_text_path):
            messagebox.showerror("Text File Missing", "Please select a valid text file before broadcasting.")
            return

        # Clear any previous stop signal before starting a new RPC session
        self.rpc_stop_event.clear()

        def loop():
            while not self.rpc_stop_event.is_set():
                try:
                    with open(self.selected_text_path, "r") as f:
                        encounters = int(f.readline() or 0)
                except Exception:
                    encounters = 0

                conf, status = rpc_shiny_confidence(encounters, self.rpc_odds)
                try:
                    self.rpc.update(
                        details=f"✦ {self.rpc_target} • {encounters} {self.rpc_counter_suffix or 'Encounters'}",
                        state=f"{status} Confidence: {conf * 100:.2f}% ",
                        large_image=cfg["icon"],
                        large_text=cfg["game"]
                    )
                except Exception:
                    pass

                self.rpc_stop_event.wait(15)

        def worker():
            try:
                rpc = Presence(cfg["application_id"])
                rpc.connect()
            except Exception as exc:
                err_msg = f"Failed to connect to Discord RPC.\n{exc}"
                self.frame.after(
                    0,
                    lambda msg=err_msg: messagebox.showerror("RPC Error", msg)
                )
                return

            def on_connected():
                if self.rpc_stop_event.is_set():
                    try:
                        rpc.clear()
                        rpc.close()
                    except Exception:
                        pass
                    return

                self.rpc = rpc
                self.rpc_game_id = game_id
                self.rpc_target = target
                self.rpc_odds = odds
                self.rpc_is_running = True
                ACTIVE_BROADCAST_PROFILE = self.profile_index
                self.rpc_thread = threading.Thread(target=loop, daemon=True)
                self.rpc_thread.start()

            self.frame.after(0, on_connected)

        threading.Thread(target=worker, daemon=True).start()

    def stop_broadcast(self):
        global ACTIVE_BROADCAST_PROFILE

        self.rpc_stop_event.set()

        if self.rpc_thread and self.rpc_thread.is_alive():
            self.rpc_thread.join(timeout=0.5)

        try:
            if self.rpc:
                self.rpc.clear()
                self.rpc.close()
        except Exception:
            pass

        self.rpc = None
        self.rpc_is_running = False
        self.rpc_last_stop_time = time.monotonic()

        if ACTIVE_BROADCAST_PROFILE == self.profile_index:
            ACTIVE_BROADCAST_PROFILE = None

    def stop_running_with_error(self, title, message):
        self.is_running = False
        self.btn_start.config(text="Start")
        self.set_settings_state(True)
        messagebox.showerror(title, message)

    def auto_check_loop(self):
        if not self.is_running:
            return

        if not self.auto_count_var.get():
            return

        is_valid, increment_amount = self.validate_required_inputs(show_popup=True)
        if not is_valid:
            self.stop_running_with_error("Invalid Settings", "Please fix the missing or invalid settings.")
            return

        frequency_seconds = max(0.1, float(self.frequency_var.get()))
        cooldown_seconds = max(1.0, float(self.cooldown_var.get()))
        threshold = float(self.threshold_var.get())

        self.frame.after(int(frequency_seconds * 1000), self.auto_check_loop)

        title = self.title_var.get().strip()
        if not title:
            self.stop_running_with_error("Invalid Window Title", "Please enter an OBS window title.")
            return

        hwnd = find_window_by_title_exact(title)
        if not hwnd:
            self.stop_running_with_error("Invalid Window Title", "No visible window found with that title.")
            return

        if is_window_minimized(hwnd):
            self.stop_running_with_error("Window Minimized", "OBS window was minimized. Monitoring stopped.")
            return

        now = time.monotonic()
        if now - self.last_match_time < cooldown_seconds:
            return

        try:
            screenshot_img = grab_window_image(hwnd)
            is_match, _ = compare_images(screenshot_img, self.selected_image_path, threshold=threshold)
            if is_match:
                new_value = increment_number_in_file(self.selected_text_path, increment_amount)
                self.last_match_time = now
                self.lbl_current_count.config(text=str(new_value))
        except Exception:
            return

    def open_configure_window(self):
        if self.configure_window and self.configure_window.winfo_exists():
            self.configure_window.lift()
            return

        self.configure_window = tk.Toplevel(self.frame)
        apply_window_style(self.configure_window)
        self.configure_window.resizable(False, False)
        self.configure_window.geometry("380x360")
        self.configure_window.minsize(380, 360)
        self._position_popup_near_root(self.configure_window)
        self.configure_window.configure(bg=DARK_BG)
        self.configure_window.grid_columnconfigure(0, minsize=320)

        self.configure_window.bind("<ButtonPress-1>", self._on_configure_drag_start)
        self.configure_window.bind("<B1-Motion>", self._on_configure_drag)

        lbl_cooldown = tk.Label(self.configure_window, text="Cooldown (seconds):")
        lbl_cooldown.grid(row=0, column=0, sticky="w", padx=12, pady=6)

        cooldown_slider = tk.Scale(
            self.configure_window, from_=1, to=10, resolution=1, orient="horizontal", variable=self.cooldown_var
        )
        cooldown_slider.grid(row=1, column=0, padx=12, pady=4, sticky="we")

        lbl_frequency = tk.Label(self.configure_window, text="Frequency (seconds):")
        lbl_frequency.grid(row=2, column=0, sticky="w", padx=12, pady=6)

        frequency_slider = tk.Scale(
            self.configure_window, from_=0.1, to=5.0, resolution=0.1, orient="horizontal", variable=self.frequency_var
        )
        frequency_slider.grid(row=3, column=0, padx=12, pady=4, sticky="we")

        lbl_threshold = tk.Label(self.configure_window, text="Confidence Treshold (%):")
        lbl_threshold.grid(row=4, column=0, sticky="w", padx=12, pady=6)

        threshold_slider = tk.Scale(
            self.configure_window, from_=0.5, to=1.0, resolution=0.01, orient="horizontal", variable=self.threshold_var
        )
        threshold_slider.grid(row=5, column=0, padx=12, pady=4, sticky="we")

        test_button = tk.Button(
            self.configure_window,
            text="Test Image",
            command=self.on_test_image,
            padx=BUTTON_PADX,
            pady=BUTTON_PADY,
            height=BUTTON_HEIGHT
        )
        test_button.grid(row=6, column=0, padx=12, pady=(8, 12), sticky="w")

        if self.is_running or not self.auto_count_var.get():
            cooldown_slider.config(state="disabled")
            frequency_slider.config(state="disabled")
            threshold_slider.config(state="disabled")

        def on_close():
            self.configure_window.destroy()
            self.configure_window = None

        self.configure_window.protocol("WM_DELETE_WINDOW", on_close)

    # ---------- Load settings ----------
    def load_from_config(self):
        self._loading_config = True

        saved_profile_name = self.load_config_value(CONFIG_KEY_PROFILE_NAME, "")
        if saved_profile_name:
            self.profile_name_var.set(saved_profile_name[:PROFILE_NAME_MAX_LENGTH])
        self.set_tab_title()

        saved_title = self.load_config_value(CONFIG_KEY_TITLE, "")
        if saved_title:
            self.title_var.set(saved_title)

        saved_image = self.load_config_value(CONFIG_KEY_IMAGE, "")
        if saved_image:
            self.image_path_var.set(saved_image)

        saved_text = self.load_config_value(CONFIG_KEY_TEXT, "")
        if saved_text:
            self.text_path_var.set(saved_text)

        cooldown = self.load_config_value(CONFIG_KEY_COOLDOWN, "5")
        try:
            self.cooldown_var.set(int(float(cooldown)))
        except ValueError:
            self.cooldown_var.set(5)

        frequency = self.load_config_value(CONFIG_KEY_FREQUENCY, "0.5")
        try:
            self.frequency_var.set(float(frequency))
        except ValueError:
            self.frequency_var.set(0.5)

        threshold = self.load_config_value(CONFIG_KEY_THRESHOLD, "0.9")
        try:
            self.threshold_var.set(float(threshold))
        except ValueError:
            self.threshold_var.set(0.9)

        increment = self.load_config_value(CONFIG_KEY_INCREMENT, str(MIN_INCREMENT))
        try:
            increment_value = int(increment)
        except ValueError:
            increment_value = MIN_INCREMENT
        increment_value = self._sanitize_increment_value(increment_value)
        self.increment_var.set(str(increment_value))

        self.rpc_game_id = self.load_config_value(CONFIG_KEY_RPC_GAME, "")
        self.rpc_target = self.load_config_value(CONFIG_KEY_RPC_TARGET, "")
        rpc_odds = self.load_config_value(CONFIG_KEY_RPC_ODDS, "8192")
        try:
            self.rpc_odds = int(rpc_odds)
        except ValueError:
            self.rpc_odds = 8192

        rpc_enabled = self.load_config_value(CONFIG_KEY_RPC_ENABLED, "0")
        self.rpc_enabled = rpc_enabled == "1"
        self.rpc_enabled_var.set(self.rpc_enabled)

        rpc_suffix = self.load_config_value(CONFIG_KEY_RPC_SUFFIX, "Encounters")
        self.rpc_counter_suffix = rpc_suffix or "Encounters"

        self._last_text_path = self.selected_text_path
        self._loading_config = False


# =========================
# MAIN UI
# =========================
register_font(FONT_PATH)

root = tk.Tk()
apply_window_style(root)
apply_dark_theme(root)
root.geometry(f"{TABLE_WIDTH}x{TABLE_HEIGHT}")
root.minsize(TABLE_WIDTH, TABLE_HEIGHT)
root.maxsize(TABLE_WIDTH, TABLE_HEIGHT)

notebook = ttk.Notebook(root, width=TABLE_WIDTH, height=TABLE_HEIGHT)
notebook.pack(anchor="center", fill="both", expand=True)
notebook.pack_propagate(False)

profiles = []
for i in range(1, 7):
    tab = ProfileTab(notebook, i)
    notebook.add(tab.frame, text=f"Profile {i}")
    tab.load_from_config()
    profiles.append(tab)


def get_active_profile():
    if not profiles:
        return None
    try:
        idx = notebook.index(notebook.select())
    except Exception:
        return profiles[0]
    if 0 <= idx < len(profiles):
        return profiles[idx]
    return profiles[0]


def on_rename_profile(_event=None):
    profile = get_active_profile()
    if not profile:
        return
    current_name = profile.profile_name_var.get().strip() or profile.default_tab_name
    new_name = simpledialog.askstring(
        "Rename Profile",
        "New profile name:",
        initialvalue=current_name,
        parent=root
    )
    if new_name is None:
        return
    new_name = new_name.strip()
    if not new_name:
        return
    new_name = new_name[:PROFILE_NAME_MAX_LENGTH]
    profile.profile_name_var.set(new_name)


notebook.bind("<Double-Button-1>", on_rename_profile)

hotkeys, global_enabled = load_hotkeys_config()
hotkey_manager = HotkeyManager(root, get_active_profile)
hotkey_manager.set_hotkeys(hotkeys)
hotkey_manager.set_global_enabled(global_enabled)
hotkey_manager.register_local_hotkeys()

root.mainloop()
